
* anal

[[https://hackage.haskell.org/package/anal][https://img.shields.io/hackage/v/anal.svg]]
[[https://github.com/tonyday567/anal/actions?query=workflow%3Ahaskell-ci][https://github.com/tonyday567/anal/workflows/haskell-ci/badge.svg]]

analysis: the prefix

* Imports

#+begin_src haskell-ng :results output
:r
:set -Wno-type-defaults
:set -Wno-name-shadowing
:set -XOverloadedLabels
:set -XOverloadedStrings
:set -XRebindableSyntax
:set -XTupleSections
:set -Wno-x-partial
import Anal
import Anal.Returns
import Control.Monad
import qualified FlatParse.Basic as FP
import Data.Time
import Data.Time.Calendar
import qualified Data.ByteString as BS
import qualified Data.ByteString.Char8 as C
import Data.Mealy
import Data.Profunctor
import Data.Maybe
import Data.Bifunctor
import NumHask.Prelude hiding (fold)
import qualified Data.Map as Map
import qualified Data.Text as Text
import Prettychart
import Chart
import qualified Prelude as P
import GHC.OverloadedLabels
import Optics.Core
import Control.Category ((>>>))
import Control.Applicative
import Chart.Compound
import Faker.Lorem
import Text.Pretty.Simple
print "imports loaded"
r <- getReturns
length r
(display, quit) <- serve
disp x = display $ x & set (#markupOptions % #markupHeight) (Just 250) & set (#hudOptions % #frames % ix 1 % #item % #buffer) 0.1

#+end_src

#+RESULTS:
: Ok, two modules reloaded.
: "imports loaded"
: 10897
: Setting phasers to stun... (port 9160) (ctrl-c to quit)

#+RESULTS:
: True

#+begin_src haskell-ng :results output
import Chart.Examples
disp $ lineExample & set #hudOptions mempty
#+end_src

#+RESULTS:
: True

* analysis
*** Accumulated return

#+begin_src haskell-ng :results output
space1 (fst <$> r) :: Maybe (Range Day)
accret = scan (second' (dipure (+))) r
decay = 0.01
rs = snd <$> r
xma = scan (ma decay) rs
xstd = scan (std decay) rs
c = dayChart ["acc return"] (fmap (second (:[])) (taker 200 accret))
disp $ c & over (#hudOptions % #axes) (List.reverse)
#+end_src

#+RESULTS:
: Just Range 1980-01-02 2023-03-17
: True

*** median versus average
**** mean versus 40th, 50th, 60th quantiles

#+begin_src haskell-ng :file other/mvq.svg :results output graphics file :exports both
mvq = (second' ((\a b -> a:(b!!1-a):b) <$> ma 0.99 <*> Data.Mealy.Quantiles.quantiles 0.99 [0.4,0.5,0.6]))

c = dayChart ["mean", "skew", "40th", "median", "60th"] (drop 1000 $ scan mvq (taker 2000 r)) & over (#hudOptions % #axes) (List.reverse) & set (#hudOptions % #legends % each % #item % #place) PlaceRight
disp c
writeChartOptions "other/mvq.svg" c
#+end_src

#+RESULTS:
[[file:other/mvq.svg]]

**** medium minus mean

#+begin_src haskell-ng :file other/mvm.svg :results output graphics file :exports both
mvm = second' ((\a b -> b - a) <$> ma 0.99 <*> median 0.99)
mvmChart = dayChart ["median - mean"] (drop 1000 $ fmap (second (:[])) $ scan mvm (taker 2000 r))
disp mvmChart
writeChartOptions "other/mvm.svg" mvmChart
 #+end_src

#+RESULTS:
[[file:other/mvm.svg]]

*** digitize median versus mean

#+begin_src haskell-ng :file other/mvmd.svg :results output graphics file :exports both
qs = [0.2,0.4,0.6,0.8]
mvmd = ((-) <$> median 0.99 <*> ma 0.99) >>> digitize 0.996 qs
d = drop 1000 $ scan (second' mvmd) (taker 2000 r)
mvmdChart = digitChart ((\x -> UTCTime x (P.fromInteger 0)) . fst <$> d) (fromIntegral . snd <$> d) (quantileNames qs)
disp mvmdChart
writeChartOptions "other/mvmd.svg" mvmdChart
 #+end_src

#+RESULTS:
[[file:other/mvmd.svg]]

* trading signals

(Today's return, Yesterday's signal)

#+begin_src haskell-ng :results output
n = 2000
pren = 1000
mvmRaw = (\a b -> a-b) <$> median 0.99 <*> ma 0.99
qs = [0.1,0.4,0.5,0.6,0.9]
d = scanRet (sigRet mvmRaw qs 0.996) n pren r
take 10 d
#+end_src

#+RESULTS:
: [(2015-04-09,(4.448e-3,0)),(2015-04-10,(5.189e-3,0)),(2015-04-13,(-4.592e-3,0)),(2015-04-14,(1.628e-3,0)),(2015-04-15,(5.135e-3,0)),(2015-04-16,(-7.79e-4,0)),(2015-04-17,(-1.1376e-2,0)),(2015-04-20,(9.193e-3,1)),(2015-04-21,(-1.482e-3,1)),(2015-04-22,(5.075e-3,1))]


#+begin_src haskell-ng :results output
Data.Mealy.fold countM (snd . snd <$> d)
#+end_src

#+RESULTS:
: fromList [(0,225),(1,550),(2,217),(3,263),(4,511),(5,234)]

cumulative return for each bucket

#+begin_src haskell-ng :file other/arc.svg :results output graphics file :exports both
n = 1000
ndrop = 0
mvmRaw = (\a b -> a-b) <$> median 0.99 <*> ma 0.99
qs = [0.1,0.4,0.5,0.6,0.9]
c = dayChart (qRangeLabel qs) (scanRet (fmap (ardList 6) (sigRet mvmRaw qs 0.996 >>> accRetDigits)) n ndrop r)
c = c & #markupOptions % renderStyle .~ Indented 4
writeChartOptions "other/arc.svg" c
disp c
#+end_src

#+RESULTS:[[file:other/arc.svg]]
* standard deviation

It looks like the market goes up when sd is declining.

What is the gradient of a moving statistic?

** return volatility chart

#+begin_src haskell-ng :file other/accsd.svg :results output graphics file :exports both
dropN = 2000

accret = scan (second' (dipure (+))) r
rebase xs = zip (fst <$> xs) (fmap (/head (snd <$> xs)) (snd <$> xs))

accChart = dayChart ["accumulated return"] (fmap (second (:[])) (rebase $ drop dropN $ taker (n+dropN) accret)) & set (#hudOptions % #legends) []
accChart' = accChart & set (#hudOptions % #axes % each % #item % #ticks % #lineTick) Nothing & set (#hudOptions % #legends) [] & over (#hudOptions % #axes) List.reverse

sdChart = (dayChart ["std"] $ second (:[]) <$> scanRet (std decay) n dropN r) & set (#hudOptions % #legends) [] & over (#hudOptions % #axes) (set (each % #item % #place) PlaceRight . drop 1) & set (#chartTree % charts' % each % #chartStyle % #color) (palette 6)

c = compoundMerge [sdChart, accChart']
writeChartOptions "other/accsd.svg" c

disp c
#+end_src

#+RESULTS:
: True

** gradient of sd

#+begin_src haskell-ng :results output
decayStd = 0.95
decayBeta1 = 0.995

stdBeta = dayChart ["std"] $ second (:[]) <$> scanRet (second' (std decayStd) >>> beta1 (ma decayBeta1)) n dropN (zip (fst <$> r) (zip [0..] (snd <$> r)))

stdBeta' = stdBeta & set (#hudOptions % #axes % each % #item % #ticks % #lineTick ) Nothing & set (#chartTree % charts' % each % #chartStyle % #color) (palette 1) & set (#hudOptions % #legends) []

betaSdChart = compoundMerge [sdChart, stdBeta']
betaSdChart' = betaSdChart & set (#hudOptions % #legends) [(Priority 20 $ defaultLegendOptions & set #legendCharts (zipWith (\t co -> (t, foldOf (#chartTree % charts') co)) ["beta of sd", "sd"] [stdBeta', sdChart]))]
disp betaSdChart'
#+end_src

#+RESULTS:
: True

*** digitize beta

#+begin_src haskell-ng :results output
qs = [0.2,0.4,0.6,0.8]
qBeta = (second' (std 0.95) >>> beta1 (ma 0.95)) >>> digitize 0.996 qs
:t qBeta
d = drop dropN $ scan (second' qBeta) (taker (n+dropN) $ (zip (fst <$> r) (zip [0..] (snd <$> r))))
betaSdDigitChart = digitChart ((\x -> UTCTime x (P.fromInteger 0)) . fst <$> d) (fromIntegral . snd <$> d) (quantileNames qs)
disp betaSdDigitChart
#+end_src

#+RESULTS:
: qBeta :: Mealy (Double, Double) Int
: True


Skew away from upper quantiles

#+begin_src haskell-ng :results output
Data.Mealy.fold countM (snd <$> d)
#+end_src

#+RESULTS:
: fromList [(0,196),(1,158),(2,230),(3,195),(4,221)]


** ToDo deconstruct this

#+begin_src haskell-ng :results output graphics file :exports both
acc = dayChart (fmap (second (:[])) (rebase $ drop dropN $ taker (n+dropN) accret))
acc' = acc & over (#hudOptions % #axes) (fmap (second (set ( #ticks % #ltick ) Nothing))) & over (#charts % charts') (fmap (colourChart (const (palette1 4))))
c = dayChart (qRangeLabel qs) (scanRet (fmap (ardList 6) (sigRet mvmRaw qs 0.996 >>> accRetDigits)) n ndrop r)

disp $ compoundMerge [c, acc']
#+end_src

#+RESULTS:
[[file:<interactive>:774:23: error: [GHC-83865]
    • Couldn't match type ‘(Day, [Double])’ with ‘Text’
      Expected: (Day, Double) -> Text
        Actual: (Day, Double) -> (Day, [Double])
    • In the first argument of ‘fmap’, namely ‘(second (: []))’
      In the first argument of ‘dayChart’, namely
        ‘(fmap
            (second (: [])) (rebase $ drop dropN $ taker (n + dropN) accret))’
      In the expression:
        dayChart
          (fmap
             (second (: [])) (rebase $ drop dropN $ taker (n + dropN) accret))
<interactive>:775:8: error: [GHC-88464] Variable not in scope: acc

<interactive>:775:125: error: [GHC-88464]
    Variable not in scope: colourChart :: (b1 -> a4) -> Chart -> Chart

<interactive>:775:145: error: [GHC-88464]
    Variable not in scope: palette1 :: t0 -> a4
    Suggested fix:
      Perhaps use one of these:
        ‘palette’ (imported from Chart), ‘paletteO’ (imported from Chart),
        ‘paletteR’ (imported from Chart)
<interactive>:778:26: error: [GHC-88464]
    Variable not in scope: acc' :: ChartOptions]]
[[file:<interactive>:767:7: error: [GHC-88464]
    Variable not in scope: dayChartRhs :: [(Day, [Double])] -> t
    Suggested fix: Perhaps use ‘dayChart’ (line 77)
<interactive>:768:8: error: [GHC-88464] Variable not in scope: acc

<interactive>:768:125: error: [GHC-88464]
    Variable not in scope: colourChart :: (b1 -> a4) -> Chart -> Chart

<interactive>:768:145: error: [GHC-88464]
    Variable not in scope: palette1 :: t0 -> a4
    Suggested fix:
      Perhaps use one of these:
        ‘palette’ (imported from Chart), ‘paletteO’ (imported from Chart),
        ‘paletteR’ (imported from Chart)
<interactive>:771:26: error: [GHC-88464]
    Variable not in scope: acc' :: ChartOptions]]

#+begin_src haskell :results output
:t d
#+end_src

#+RESULTS:
: d :: [(Day, Int)]

** bucket chart

#+begin_src haskell-ng :results output
n = 2000
dropN = 100
qs = [0.1, 0.5, 0.9] :: [Double]
decayStd = 0.95
decayBeta1 = 0.95
decayQ = 0.95
qBeta' = (first snd) <$> ((,) <$> id <*> (second' (std decayStd) >>> beta1 (ma decayBeta1) >>> digitize decayQ qs >>> delay1 0))
buckets = fmap (ardList ((length qs :: Int) + 1)) (qBeta' >>> accRetDigits)
xs = (drop dropN $ scan (second' buckets) (taker (n+dropN) $ (zip (fst <$> r) (zip [0..] (snd <$> r)))))
bucketChart = dayChart (qRangeLabel qs) xs
disp bucketChart
#+end_src

#+RESULTS:
: True


** ToDo betaSdDigitChart

#+begin_src haskell-ng :results output
qBeta = (second' (std decayStd) >>> beta1 (ma decayBeta1)) >>> digitize decayQ qs
d = drop dropN $ scan (second' qBeta) (taker (n+dropN) $ (zip (fst <$> r) (zip [0..] (snd <$> r))))
betaSdDigitChart = digitChart ((\x -> UTCTime x (P.fromInteger 0)) . fst <$> d) (fromIntegral . snd <$> d) (quantileNames qs)
disp betaSdDigitChart
#+end_src



** ToDo vert

#+begin_src haskell :results output
toCT co = addHud (view #hudOptions co) (view #charts co)
#+end_src

#+RESULTS:

#+begin_src haskell :results output
disp $ mempty & #charts .~ stack 2 0.1 [toCT bucketChart, toCT compChart', toCT betaSdDigitChart, toCT betaSdChart', toCT decayChart]
#+end_src

#+RESULTS:
: <interactive>:156:64: error: [GHC-88464]
:     Variable not in scope: compChart'
:
: <interactive>:156:81: error: [GHC-88464]
:     Variable not in scope: betaSdDigitChart
:
: <interactive>:156:104: error: [GHC-88464]
:     Variable not in scope: betaSdChart'

#+begin_src haskell :results output
ts = pack <$> ["std decay = " <> show decayStd, "beta1 decay = " <> show decayBeta1, "quantile decay = " <> show decayQ]
s = defaultTextStyle & #anchor .~ AnchorStart
ts' = [TextChart s (zipWith (\t x -> (t, Point 0 x)) ts [0..])]
decayChart = mempty & #charts .~ unnamed (ts' <> [padChart 0.2 ts']) :: ChartOptions
#+end_src

* ToDo all in one

- [ ] try and predict future stats
  - [ ] calculate ma std etc
  - [ ] chart of expected future distribution
- [ ] track a p&l
  - [ ] random p&l streams
- [X] smaller text chart
- [X] bar chart labels too close and a bit too small
- [X] ticks not scaling and fuzzy
  - function to scale hud along with the chart (can only do this once I assume, but maybe the chart section of HudChart can help)
- [X] combine digit chart with digit accumulation
- [X] better order of stack

#+begin_src haskell-ng :results output
-- parameters
n = 2000
dropN = 100
qs = [0.1, 0.5, 0.8] :: [Double]
decayStd = 0.95
decayBeta1 = 0.99
decayQ = 0.996
ri = zip [0..] (snd <$> r)
days = reindex n dropN id (fst <$> r)

accret = scan (second' (dipure (+))) r
rebase xs = zip (fst <$> xs) (fmap (/head (snd <$> xs)) (snd <$> xs))

accChart = lchart Nothing (palette 0) (rebase n dropN (scan (dipure (+)) (snd <$> r)))

finishHud = #axes %~ (<> [dayAxis days]) >>> #frames %~ (<> [(Priority 30, defaultFrameOptions & #buffer .~ 0.1)]) :: HudOptions -> HudOptions

sdChart = lchart (Just PlaceLeft) (palette 1) (reindex n dropN (scan (std decayStd)) (snd <$> r))

betaChart = lchart (Just PlaceRight) (palette 2) (reindex n dropN (scan (second' (std decayStd) >>> beta1 (ma decayBeta1))) ri)

sdCharts = compoundMerge [sdChart,betaChart, accChart & #hudOptions %~ finishHud]

qBeta = (second' (std decayStd) >>> beta1 (ma decayBeta1)) >>> digitize decayQ qs
rDigit = reindex n dropN (scan qBeta) ri
cs = Data.Mealy.fold countM (rDigit)
qCountChart = barChart defaultBarOptions (BarData [fromIntegral <$> toList cs] (qRangeLabel qs) []) & #hudOptions % #frames %~ (<> [(Priority 30, defaultFrameOptions & #buffer .~ 0.2)]) & #hudOptions % #titles %~ (<> [(Priority 10, defaultTitle "quantile counts" & #buffer .~ 0.2 & #style % #color .~ palette 1)])

qBetaChart = digitChart ((\x -> UTCTime x (P.fromInteger 0)) <$> days) (fromIntegral <$> rDigit) (quantileNames qs) & #hudOptions % #axes .~ []

qBeta' = (first snd) <$> ((,) <$> id <*> (second' (std decayStd) >>> beta1 (ma decayBeta1) >>> digitize decayQ qs >>> delay1 0))
buckets = fmap (ardList ((length qs :: Int) + 1)) (qBeta' >>> accRetDigits)
xs = (drop dropN $ scan (second' buckets) (taker (n+dropN) $ (zip (fst <$> r) (zip [0..] (snd <$> r)))))
bucketChart = dayChart (qRangeLabel qs) xs

accBucketChart = compoundMerge [qBetaChart, bucketChart]

ts = pack <$> reverse ["std decay = " <> show decayStd, "beta1 decay = " <> show decayBeta1, "quantile decay = " <> show decayQ, "quantiles = " <> show qs]
s = defaultTextStyle & #anchor .~ AnchorStart & #hsize .~ 0.65
ts' = zipWith (\t x -> TextChart s [(t, Point 0 x)]) ts [0..]
decayChart = (mempty::ChartOptions) & (#hudOptions % #frames .~ [(Priority 30, FrameOptions (Just clear) 0.05)]) & (#charts .~ unnamed ts')

disp $ mempty & #charts .~ stack' 2 0.1 ([toCT sdCharts, toCT qCountChart, toCT accBucketChart, toCT decayChart])
#+end_src

#+RESULTS:
#+begin_example
<interactive>:817:40: error: [GHC-83865]
    • Couldn't match expected type: t0 -> [Double] -> [Double]
                  with actual type: [(a0, b0)]
    • The function ‘rebase’ is applied to three visible arguments,
        but its type ‘Divisive b => [(a, b)] -> [(a, b)]’ has only one
      In the third argument of ‘lchart’, namely
        ‘(rebase n dropN (scan (dipure (+)) (snd <$> r)))’
      In the expression:
        lchart
          Nothing (palette 0)
          (rebase n dropN (scan (dipure (+)) (snd <$> r)))
<interactive>:819:46: error: [GHC-18872]
    • Couldn't match type: Priority FrameOptions
                     with: (a0 -> Priority a0, FrameOptions)
        arising from the overloaded label ‘#frames’
    • In the first argument of ‘(%~)’, namely ‘#frames’
      In the second argument of ‘(>>>)’, namely
        ‘#frames
           %~ (<> [(Priority 30, defaultFrameOptions & #buffer .~ 0.1)])’
      In the expression:
          #axes %~ (<> [dayAxis days])
            >>>
              #frames
                %~ (<> [(Priority 30, defaultFrameOptions & #buffer .~ 0.1)]) ::
            HudOptions -> HudOptions
<interactive>:825:72: error: [GHC-88464]
    Variable not in scope: finishHud :: HudOptions -> HudOptions
<interactive>:830:233: error: [GHC-88464]
    Variable not in scope: defaultTitle :: t0 -> a5
    Suggested fix:
      Perhaps use one of these:
        ‘defaultTick’ (imported from Chart),
        ‘defaultStyle’ (imported from Chart)
<interactive>:844:117: error: [GHC-64725]
    • Data constructor ‘ChartOptions’ doesn't have a field named ‘charts’
    • In the first argument of ‘(.~)’, namely ‘#charts’
      In the second argument of ‘(&)’, namely ‘(#charts .~ unnamed ts')’
      In the expression:
        (mempty :: ChartOptions)
          & (#hudOptions % #frames
               .~ [(Priority 30, FrameOptions (Just clear) 0.05)])
          & (#charts .~ unnamed ts')
<interactive>:846:48: error: [GHC-88464]
    Variable not in scope: sdCharts :: ChartOptions
    Suggested fix:
      Perhaps use one of these:
        ‘Ghci122.sdChart’ (imported from Ghci122),
        ‘Ghci128.sdChart’ (imported from Ghci128),
        ‘Ghci134.sdChart’ (imported from Ghci134)

<interactive>:846:63: error: [GHC-88464]
    Variable not in scope: qCountChart :: ChartOptions

<interactive>:846:102: error: [GHC-88464]
    Variable not in scope: decayChart :: ChartOptions
    Suggested fix:
      Perhaps use one of these:
        ‘dayChart’ (line 77),
        data constructor ‘RectChart’ (imported from Chart),
        ‘betaChart’ (line 823)
#+end_example


#+begin_src haskell-ng :results output
:i rebase
#+end_src

#+RESULTS:
: rebase :: Divisive b => [(a, b)] -> [(a, b)]
:   	-- Defined at <interactive>:579:1


#+begin_src haskell-ng :results output
-- parameters
n = 2000
dropN = 100
qs = [0.1, 0.5, 0.8] :: [Double]
decayStd = 0.95
decayBeta1 = 0.99
decayQ = 0.996
ri = zip [0..] (snd <$> r)
days = reindex n dropN id (fst <$> r)

accChart = lchart Nothing (palette1 0) (rebase n dropN (scan (dipure (+)) (snd <$> r)))

finishHud = #axes %~ (<> [dayAxis days]) >>> #frames %~ (<> [(Priority 30, defaultFrameOptions & #buffer .~ 0.1)]) :: HudOptions -> HudOptions

sdChart = lchart (Just PlaceLeft) (palette1 1) (reindex n dropN (scan (std decayStd)) (snd <$> r))

betaChart = lchart (Just PlaceRight) (palette1 2) (reindex n dropN (scan (second' (std decayStd) >>> beta1 (ma decayBeta1))) ri)


sdCharts = compoundMerge [sdChart,betaChart, accChart & #hudOptions %~ finishHud]

qBeta = (second' (std decayStd) >>> beta1 (ma decayBeta1)) >>> digitize decayQ qs
rDigit = reindex n dropN (scan qBeta) ri
cs = Data.Mealy.fold countM (rDigit)
qCountChart = barChart defaultBarOptions (BarData [fromIntegral <$> toList cs] (qRangeLabel qs) []) & #hudOptions % #frames %~ (<> [(Priority 30, defaultFrameOptions & #buffer .~ 0.2)]) & #hudOptions % #titles %~ (<> [(Priority 10, defaultTitle "quantile counts" & #buffer .~ 0.2 & #style % #color .~ palette1a 1 1)]) & #hudOptions % #axes %~ fmap (second (#bar .~ Nothing))


qBetaChart = digitChart ((\x -> UTCTime x (P.fromInteger 0)) <$> days) (fromIntegral <$> rDigit) (quantileNames qs) & #hudOptions % #axes .~ []

qBeta' = (first snd) <$> ((,) <$> id <*> (second' (std decayStd) >>> beta1 (ma decayBeta1) >>> digitize decayQ qs >>> delay1 0))
buckets = fmap (ardList ((length qs :: Int) + 1)) (qBeta' >>> accRetDigits)
xs = (drop dropN $ scan (second' buckets) (taker (n+dropN) $ (zip (fst <$> r) (zip [0..] (snd <$> r)))))
bucketChart = dayChart (qRangeLabel qs) xs

accBucketChart = compoundMerge [qBetaChart, bucketChart]

ts = pack <$> reverse ["std decay = " <> show decayStd, "beta1 decay = " <> show decayBeta1, "quantile decay = " <> show decayQ, "quantiles = " <> show qs]
s = defaultTextStyle & #anchor .~ AnchorStart & #hsize .~ 0.65
ts' = zipWith (\t x -> TextChart s [(t, Point 0 x)]) ts [0..]
decayChart = (mempty::ChartOptions) & (#hudOptions % #frames .~ [(Priority 30, FrameOptions (Just clear) 0.05)]) & (#charts .~ unnamed ts')
-- disp $ qCountChart & #hudOptions % #axes %~ fmap (second (#bar .~ Nothing))

disp $ mempty & #charts .~ stack' 2 0.1 ([toCT sdCharts, toCT qCountChart, toCT accBucketChart, toCT decayChart])
#+end_src

#+RESULTS:
: True
